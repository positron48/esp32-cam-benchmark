**Задача**: Создать полностью автоматизированный бенчмарк для ESP32-CAM, который:

1. **Сравнивает** передачу видеопотока (разные протоколы и параметры) и передачу команд управления (отдельно и совместно с видео).
2. **Перебирает** все сочетания параметров: разрешение, качество JPEG, режим “сырые данные” vs. сжатие, включённый/отключённый мониторинг (метрики).
3. **Автоматически** собирает прошивку на PlatformIO для ESP32-CAM (с использованием FreeRTOS, двух ядер), прошивает, запускает тесты.
4. **Сохраняет** логи и полученный видеопоток на Python-клиенте для анализа. Приоритет — **максимальное быстродействие**.

**Шаги для создания:**

1. **Структура проекта**:

   - ```
     firmware/
     ```

      для ESP32-CAM (PlatformIO).

     - Разделить логику видеопередачи и управления на отдельные файлы (например, `video_http.cpp`, `video_udp.cpp`, `ctrl_http.cpp`, `ctrl_udp.cpp`), плюс общий `main.cpp` с FreeRTOS-задачами.

   - `bench_config.yml` описывает все комбинации параметров (протокол, разрешение, качество, включение мониторинга).

   - Скрипты `build_firmware.sh`, `flash_firmware.sh` для сборки и прошивки.

   - Python-клиент 

     ```
     run_tests.py
     ```

      c бенчмарком:

     - Перебирает все параметры,
     - Собирает и прошивает ESP32-CAM,
     - Запускает тест (собирая видеопоток и логи),
     - Сохраняет результаты (логи, fps, задержки, видео).

2. **Серверная часть (PlatformIO)**:

   - Каждый протокол в **отдельном файле** (HTTP/RTSP/UDP/WebRTC для видео; HTTP/UDP/MQTT/WebSocket — для управления).
   - В `main.cpp` настроить FreeRTOS-задачи (два ядра) — например, одна задача обрабатывает видео, другая — команды управления.
   - Ключевые параметры передавать через `#define` (разрешение, качество, включение метрик).
   - Собрать в общий “скелет” с минимальным ручным вмешательством при переключении протоколов.

3. **Конфиг `bench_config.yml`**:

   - Списком все варианты (протокол_видео, протокол_управление, разрешение, качество, мониторинг=on/off, raw/jpeg).
   - Пример: `{video_proto: "UDP", ctrl_proto: "HTTP", res: "VGA", quality: 10, metrics: false}`.

4. **Клиентская часть (Python)**:

   - Читает `bench_config.yml`,
   - Вызывает `build_firmware.sh` с нужными `-D` флагами,
   - Вызывает `flash_firmware.sh`,
   - Ждёт, пока плата загрузится,
   - Запускает тест:
     1. Если включена видеопередача — подключается (HTTP/RTSP/UDP/WebRTC), принимает и **сохраняет** видеопоток.
     2. Параллельно (или последовательно) отправляет команды управления (HTTP, UDP, MQTT) и собирает метрики задержек.
   - По окончании теста формирует логи (JSON/CSV), сохраняет видео/кадры в `results/`.

5. **Приоритет быстродействия**:

   - Предусмотреть режим без лишнего логирования на ESP32 (выключить Serial печать, если `-D ENABLE_METRICS=0`).
   - Использовать FreeRTOS и два ядра для параллельной обработки (отдельные задачи для кодирования видео и приёма команд).

---

Да, реализуй что осталось

---

mqtt не нужен

---

можем настроить какие-то проверки code style, статический анализ, добавить makefile с всеми нужными командами и завернуть все это в github ci?

---

а можем использовать venv, чтобы не ставить все зависимости локально?

---

создай readme и опиши подробно все необходимое 

---

запусти make check, мб можно автофикс делать?

---

актуализируй readme

---

давай пройдем по этим шагам

---

продолжай x2

---

запускай make fix и исправляй ошибки

---

убери пока test_results_format, там по факту пытается собраться прошивка для каждой комбинации, это не ок

---

нужно чтобы make fix не менял порядок подключения заголовочных файлов в cpp

---

основная ветка master, обнови ci

---

запусти make test и поправь ошибки

---

сделай чтобы make fix работал без сбоев до конца

---

добавь cppcheck_errors.txt в игнор

---

можем вывести в github ci, какой именно файл он считает невалидным и почему? А логи вывода файла форматирования убрать, он под гитом

---

так в ci мы же не меняем файлы и git diff/status всегда будут пустыми, нет?

---

так погоди, а давай в ci добавим вывод на экран git diff, который триггерит ошибку

---

как будто никаких изменений нет, но все равно триггерится ошибка?

---

давай в ci пока закомментируем этап сборки прошивки и удалим отправку покрытия в codecov

---

Your workflow is using a version of actions/cache that is scheduled for deprecation, actions/cache@v2. Please update your workflow to use either v3 or v4 of actions/cache to avoid interruptions.

---

CI прошел, убери все костыли для версии clang-format-14, используй без указания версии стандартный пакет, убери кастомный репозиторий

---

а теперь удали тест на проверку директорий, он бестолковый какой-то

--

добавь в readme значки

---

давай переместим firmware/src в src

---

давай попробуем собрать прошивку make build

---

давай добавим в проект возможность запустить 1 конкретный тест с определенными параметрами

---

добавь логи по процессу тестирования

---

откуда идет запись видео, если нет ни подключения устройства ни видеопотока?

---

SSID и пароль нужно разместить в .env файле и убрать из гита

---

запусти make fix

---

в рамках теста нужно также загружать прошивку на esp, а еще через COM-порт парсить полученный IP адрес и направлять запросы на этот IP

---

проблема не в прошивке, а в том как мы подключаемся или какие сигналы посылаем. Из arduino ide я подключаюсь к этому же порту и все ок

---

прочитай заново main.cpp и проверь верно ли мы работаем с портом теперь

---

погоди, у нас тут тесты и куча вариантов прошивок в зависимости от параметров, что именно соберется через pio?

---

а давай зададим параметры по умолчанию в platformio.ini и опишем там в комментарийх как с ними работать и какие варианты возможны

---

давай соберем и прошьем теперь все через pio

---

давай выводить в порт больше логов

---

WIFI_SSID не пробрасывается из .env

---

проверь как мы работаем с устройством по коду, потому что оно доступно. Скорее всего не хватает Serial device в списке разрешенных устройств или что-то такое

---

давай еще запускать прошивку не через esptool, а через pio

---

устройство прошивается, но из порта ничего не считывается. Убедись, что ты читаешь порт также как это делает platformio

---

порт успешно читается, но IP не распознается

---

запусти make check

---

сейчас есть проблема с тем, что устройство не формирует видеопоток. У меня в /home/ubuntu/Arduino/ESP32-CAM_MJPEG2SD лежит проект под ардуино, где есть рабочая реализация передачи видео - можешь посмотреть туда и попробовать поправить текущий код, но помни что нам нужно быстродействие и минимальная реализация передачи видео для бенчмарка. Проект  MJPEG2SD очень избыточен

---

я руками подключился к http://192.168.0.113:80/stream и http://192.168.0.113:80/video - картинка в браузере есть корректная, но статичная, если обновлять страницу - кадр обновляется. Нужно починить подключение к стриму из теста, т.к. он похоже ошибочно считает что стрима нет

---

давай еще раз, стрим идет корректно, просто не обновляется, сделай так, чтобы в html встраивался не статичный кадр, а картинка обновлялась самостоятельно

---

** некоторые изыскания по http video стриму с o1 **

---

нужно модифцировать тест:

1. после старта прослушивания какое-то время в порт пишется мусор, который может привести к остановке выполнения скрипта - игнорируй этот мусор пока не встретишь  строку === ESP32-CAM Initialization ===, начиная с неё можно выводить вывод в консоль.

2. Ожидай в течение 10 секунд инициализации и получения IP адреса и умирай только после

3. Стрим доступен для http по адресу /video, не /stream как ожидается сейчас

---

если я не передаю --control-protocol - не нужно тестировать его. Также выводи больше логов по записи стрима, сейчас как будто на этапе подключения долго висит скрипт

также добавь флаг, чтобы не собирать прошивку, а только запустить тест

---

обнови редми в соответствии с этими изменениями

---

пиши также метрики запуска теста, какие сможешь на стороне python

---

метрики сохраняются в results/metrics?

файлы должны называться с указанием всех параметров, от которых они зависят - касается логов, видео и метрик

---

в метриках нужно фиксировать количество кадров за каждую зафиксированную секунду, чтобы потом можно было построить график

---

frame_timestamps не нужен
вместо frame_time_avg_ms лучше считать перцентили

---

1. нужно брать в учет только полные секунды, сейчас первая и последняя искажают результаты
2. в рамках теста 2 раза происходит получение IP устройства, из-за этого оно перезагружается по факту 2 раза

---

теперь вместо 30 секунд мы анализируем 28 - нужно добавить 2 секунды и не считать их, т.к. они неполные

также статистика по перцентилям показывает время на кадр, нужно сделать еще сбор по перцентилям количество кадров

---

в метриках теперь секунды 0-28, а должны быть 1-30

---

давай перцентили по секундам считать наоборот, это будет более логично
50 - 50% секунд укладываются в X фпс
99 - 99% секунд укладываются в Y фпс, причем 99 перцентиль будет меньше или равен 50

---

2025-01-11 15:33:18,200 - INFO - Captured 240 frames in 11.13 seconds (21.57 fps)

давай еще вот такие логи писать по секундам, а не каждый 30 фреймов

---

2025-01-11 15:35:15,674 - INFO - Captured 97 frames in 5.06 seconds (19.19 fps)
2025-01-11 15:35:16,642 - INFO - Captured 118 frames in 6.02 seconds (19.59 fps)

давай выводить не накопленным итогом

---

а в скобках пусть будет средний fps

---

добавь 75 перцентиль

---

запусти make check и исправь ошибки

---

для исправлений запускай make fix и затем make check, можно в одну команду

---

run_tests разросся до неприличных размеров, давай создадим отдельную папку benchmark, куда поместим python приложение, которое будет собрано из этого файла

---

обнови ридми, опиши как теперь запускать тесты и бенчмарк в целом, проверь все ли актуально

---

кажется ты потерял при переносе весь сбор метрик и логов, который мы делали. Проверь run_tests_backup.py - я восстановил файлик чтобы был для примера

---

o1: смотри, в этом файле тестируется видео и собираются метрики. Проблема в том, что ESP не отдает стабильные 25 кадров и 30-секундная запись генерирует 11 секундное видео (примерно). Нужно сделать так, чтобы видео соответствовало реальному захвату, т.е. показывать все задержки, заикания и реальный записанный fps.

Если нужно для этого изменить формат видео - можно это сделать, но важно чтобы видеофайл был близок к реальному захвату

---

