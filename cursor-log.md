**Задача**: Создать полностью автоматизированный бенчмарк для ESP32-CAM, который:

1. **Сравнивает** передачу видеопотока (разные протоколы и параметры) и передачу команд управления (отдельно и совместно с видео).
2. **Перебирает** все сочетания параметров: разрешение, качество JPEG, режим “сырые данные” vs. сжатие, включённый/отключённый мониторинг (метрики).
3. **Автоматически** собирает прошивку на PlatformIO для ESP32-CAM (с использованием FreeRTOS, двух ядер), прошивает, запускает тесты.
4. **Сохраняет** логи и полученный видеопоток на Python-клиенте для анализа. Приоритет — **максимальное быстродействие**.

**Шаги для создания:**

1. **Структура проекта**:

   - ```
     firmware/
     ```

      для ESP32-CAM (PlatformIO).

     - Разделить логику видеопередачи и управления на отдельные файлы (например, `video_http.cpp`, `video_udp.cpp`, `ctrl_http.cpp`, `ctrl_udp.cpp`), плюс общий `main.cpp` с FreeRTOS-задачами.

   - `bench_config.yml` описывает все комбинации параметров (протокол, разрешение, качество, включение мониторинга).

   - Скрипты `build_firmware.sh`, `flash_firmware.sh` для сборки и прошивки.

   - Python-клиент 

     ```
     run_tests.py
     ```

      c бенчмарком:

     - Перебирает все параметры,
     - Собирает и прошивает ESP32-CAM,
     - Запускает тест (собирая видеопоток и логи),
     - Сохраняет результаты (логи, fps, задержки, видео).

2. **Серверная часть (PlatformIO)**:

   - Каждый протокол в **отдельном файле** (HTTP/RTSP/UDP/WebRTC для видео; HTTP/UDP/MQTT/WebSocket — для управления).
   - В `main.cpp` настроить FreeRTOS-задачи (два ядра) — например, одна задача обрабатывает видео, другая — команды управления.
   - Ключевые параметры передавать через `#define` (разрешение, качество, включение метрик).
   - Собрать в общий “скелет” с минимальным ручным вмешательством при переключении протоколов.

3. **Конфиг `bench_config.yml`**:

   - Списком все варианты (протокол_видео, протокол_управление, разрешение, качество, мониторинг=on/off, raw/jpeg).
   - Пример: `{video_proto: "UDP", ctrl_proto: "HTTP", res: "VGA", quality: 10, metrics: false}`.

4. **Клиентская часть (Python)**:

   - Читает `bench_config.yml`,
   - Вызывает `build_firmware.sh` с нужными `-D` флагами,
   - Вызывает `flash_firmware.sh`,
   - Ждёт, пока плата загрузится,
   - Запускает тест:
     1. Если включена видеопередача — подключается (HTTP/RTSP/UDP/WebRTC), принимает и **сохраняет** видеопоток.
     2. Параллельно (или последовательно) отправляет команды управления (HTTP, UDP, MQTT) и собирает метрики задержек.
   - По окончании теста формирует логи (JSON/CSV), сохраняет видео/кадры в `results/`.

5. **Приоритет быстродействия**:

   - Предусмотреть режим без лишнего логирования на ESP32 (выключить Serial печать, если `-D ENABLE_METRICS=0`).
   - Использовать FreeRTOS и два ядра для параллельной обработки (отдельные задачи для кодирования видео и приёма команд).

---

Да, реализуй что осталось

---

mqtt не нужен

---

можем настроить какие-то проверки code style, статический анализ, добавить makefile с всеми нужными командами и завернуть все это в github ci?

---

а можем использовать venv, чтобы не ставить все зависимости локально?

---

создай readme и опиши подробно все необходимое 

---

запусти make check, мб можно автофикс делать?

---

актуализируй readme

---

давай пройдем по этим шагам

---

продолжай x2

---

запускай make fix и исправляй ошибки

---

убери пока test_results_format, там по факту пытается собраться прошивка для каждой комбинации, это не ок

---

